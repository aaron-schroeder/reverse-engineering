<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>grade-adjusted-pace</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="reverse-engineering-stravas-grade-adjusted-pace" class="level1">
<h1>Reverse-engineering Strava’s Grade Adjusted Pace</h1>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="st">'../validation'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> common <span class="im">import</span> load_activity_summary_data</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> common <span class="im">import</span> load_timeseries_data</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While exploring my personal activity data lake, I found that Strava seemed to be applying the grade adjustment factor to <em>distance</em>, not to <em>pace</em>. That made me wonder if their conceptual model of “running difficulty” was similar to the “cost of running” model used in [[Minetti (2002)]]. In that paper, the “cost” of running was given in terms of energy consumed by the human body, per unit distance, per unit mass. In other words, the units of this quantity are calories per kilogram per kilometer. When choosing a model to assume for my reverse-engineered product, I figured the simpler the better. The embedded assumptions in this model are: - The cost of running depends on grade, but is independent of speed. - Every person’s cost of running curve looks exactly the same. For a given slope, every person spends the same amount of energy (per unit body mass) to cover a mile.</p>
<p>If either of these assumptions sounds absurd, remember: the cost of running is in terms of body mass and distance covered. In order to model how much energy a person consumes getting from A to B, the cost of running gets multiplied by the individual’s body mass. And in order to determine the individual’s rate of energy consumption, the quantity is divided by time; to cover A to B in a very short time, a very high burn rate is required.</p>
<p>Here is the equation:</p>
<p><span class="math display">\[C_r(i) = 155.4i^5 - 30.4i^4 -43.3i^3 + 46.3i^2 + 19.5i + 3.6\]</span></p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> specialsauce.sources.minetti <span class="im">import</span> cost_of_running</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>gradient_array <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.45</span>, <span class="fl">0.45</span>, <span class="dv">100</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.plot(gradient_array, cost_of_running(gradient_array))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="fl">0.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="fl">0.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>&lt;matplotlib.lines.Line2D at 0x7efd7bcac550&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="grade-adjusted-pace_files/figure-html/cell-3-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>When considering what form to assume for Strava’s grade adjustment factor function, I figured it would be desirable to use the same form as [[Minetti (2002)]]. The general form of that equation is</p>
<p><span class="math display">\[
f(g) = \Sigma_0^5 c_i  g^i
\]</span></p>
<p>Just a fifth-order polynomial, where <span class="math inline">\(g\)</span> is decimal grade.</p>
<p>I have a hunch that Strava’s <em>old</em> Grade Adjusted Pace product was based on using the Minetti equation to compute a ratio of the cost of running on a slope to the cost of running on flat ground:</p>
<p><span class="math display">\[
  f(g) = c_r(g) / c_r(0)
\]</span></p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>adjustment_factor_array <span class="op">=</span> cost_of_running(gradient_array) <span class="op">/</span> cost_of_running(<span class="fl">0.0</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="fl">1.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="fl">0.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.plot(gradient_array, adjustment_factor_array)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="grade-adjusted-pace_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>…and I think it would be intuitive to calculate adjusted point-to-point distance like: <span class="math display">\[
  \Delta x_g = f(g) \Delta x
\]</span></p>
<p>In words, that means that the adjusted distance from A to B is a function of the grade at point A.</p>
<p>I want to fit a similar curve to Strava’s “grade adjustment factor” (my term). So how can I make it happen, using the data I have at my fingertips?</p>
<section id="the-data" class="level2">
<h2 class="anchored" data-anchor-id="the-data">The data</h2>
<section id="time-series-from-the-strava-api" class="level3">
<h3 class="anchored" data-anchor-id="time-series-from-the-strava-api">Time series from the Strava API</h3>
<p>I have access to all the time series data for my Strava activities, going back to 2019. In this private dataset, there are over 2.5 million samples, each representing an observation recorded on my activity tracker (a GPS watch). Each observation corresponds to a discrete point in time, and contains a number of variables:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>panel_ts_df <span class="op">=</span> load_timeseries_data()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>panel_ts_df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>Index(['lat', 'lon', 'distance', 'altitude', 'velocity_smooth', 'grade_smooth',
       'cadence', 'heartrate', 'temp', 'watts', 'moving', 'type'],
      dtype='object')</code></pre>
</div>
</div>
<p>The variable names largely speak for themselves.</p>
<p>Only two of these variables will be used in my analysis. The first, <code>distance</code>, represents cumulative distance traveled from the start of the activity. A bit of rearranging gives me what I am really after: the point-to-point distances between each sample:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>delta_x <span class="op">=</span> panel_ts_df[<span class="st">'distance'</span>].groupby(<span class="st">'id'</span>).diff(<span class="dv">1</span>).shift(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>delta_x.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>count    2.581882e+06
mean     5.146323e+00
std      6.688147e+00
min      0.000000e+00
25%      1.300000e+00
50%      3.000000e+00
75%      3.900000e+00
max      3.067000e+02
Name: distance, dtype: float64</code></pre>
</div>
</div>
<p>Next, I need to grab a time series that Strava calculates on its backend: <code>grade_smooth</code>. As the name suggests: - This represents grade (terrain slope along the path: <span class="math inline">\(\Delta y / \Delta x\)</span>). - The time series has also been smoothed in some way. Since grade represents the change in elevation per change in distance, it is sensitive to noisy data.</p>
<p>The grade-smoothing operation is an element of Strava’s special sauce. Until I understand this algorithm (among other secrets), I will be forced to continue uploading my activity data to Strava if I want to see the calculated grade time series. That is irrelevant to this post, but it reflects my long-term ambitions: personal data liberation.</p>
<p>Let’s get back into the data.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>grade <span class="op">=</span> panel_ts_df[<span class="st">'grade_smooth'</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>grade.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>count    2.583119e+06
mean     1.325603e+00
std      1.480232e+01
min     -5.000000e+01
25%     -3.800000e+00
50%      3.000000e-01
75%      7.300000e+00
max      5.000000e+01
Name: grade_smooth, dtype: float64</code></pre>
</div>
</div>
<p>Note the maximum and minimum values: Strava’s algorithm will <em>never</em> report a grade steeper than 50%. That’s a steepness of 5 meters vertical per 10 meters horizontal. Most terrain does not get that steep, unless you go to the mountains. It looks like I am getting sidetracked again.</p>
</section>
<section id="grade-adjusted-distance-values-from-a-bulk-data-download" class="level3">
<h3 class="anchored" data-anchor-id="grade-adjusted-distance-values-from-a-bulk-data-download">Grade Adjusted Distance values from a bulk data download</h3>
<p>You know how you can ask for a bulk downloada of all the data you’ve uploaded to apps and services? Strava is no different. And there’s a lot of good stuff in there. What I need is the Grade Adjusted Distance for each activity. Dividing Grade Adjusted Distance by Moving Time yields Grade Adjusted Pace, which is a feature Strava pulled behind their subscription paywall in 2020. Even non-subscribers will see Grade Adjusted Distance in their bulk data download, which really seems like an oversight, but I’ll keep quiet since it facilitates this analysis.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>activities_df <span class="op">=</span> load_activity_summary_data()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>grade_adjusted_distance <span class="op">=</span> activities_df.set_index(<span class="st">'Activity ID'</span>)[<span class="st">'Grade Adjusted Distance'</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>grade_adjusted_distance.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>count     1163.000000
mean     12897.031030
std       7409.794250
min          0.900000
25%       7235.500000
50%      12162.000000
75%      16649.400391
max      73662.101562
Name: Grade Adjusted Distance, dtype: float64</code></pre>
</div>
</div>
<p>Meters are the distance units here. So in terms of Grade Adjusted Distance, my longest activity is 73.6 kilometers (and I won’t soon forget it). And my average is somewhere between 12 and 13 kilometers. That’s apparently my sweet spot!</p>
</section>
</section>
<section id="the-method" class="level2">
<h2 class="anchored" data-anchor-id="the-method">The method</h2>
<section id="linear-regression-using-sklearn" class="level3">
<h3 class="anchored" data-anchor-id="linear-regression-using-sklearn">Linear regression using <code>sklearn</code></h3>
<p>I could go about this a few different ways. I’m choosing to use <code>sklearn</code> because it facilitates a generalizable approach - one not limited to polynomial regressions.</p>
<p>Now I’m going to switch hats and start using the domain language of data science. For each activity in my personal <em>data lake</em>, I’ll <em>engineer</em> a number of <em>features</em> I’ll take the time series containing samples of all the variables measured during the activity as well as those calculated by Strava (the activity’s <em>multivariate time series</em>); then I will do some math on them to produce some scalar values - the features. I am <em>extracting</em> features from the multivariate timeseries. In keeping with the approach of [[Minetti (2002)]], the features will be of the form</p>
<p><span class="math display">\[
  ftr_m = \sum\limits_{i=0}^{N_{obs}-1} g_i^m \Delta x(i)
\]</span></p>
<p>Why? Maybe let’s take a step back.</p>
<p>The total distance of an activity is simply the sum of its point-to-point distance time series.</p>
<p><span class="math display">\[
  x_g = \sum\limits_0^{N_{obs}-1} \Delta x(i)
\]</span></p>
<p>Similarly, the Grade Adjusted Distance of an activity is the sum of its adjusted point-to-point distance.</p>
<p><span class="math display">\[
  x_g = \sum\limits_0^{N_{obs}-1} f(g(i)) \Delta x(i)
\]</span></p>
<p>Since I decided to model the adjustment factor as a polynomial function of grade, this expression becomes</p>
<p><span class="math display">\[
  x_g = \sum\limits_{i=0}^{N_{obs}-1} \sum\limits_{j=0}^5 c_j \cdot g^j(i) \cdot \Delta x(i)
\]</span></p>
<p>Remember, all I’m looking to determine in this analysis are the coefficients <span class="math inline">\(c_{0..5}\)</span>. Everything else is in the data I have available: each activity’s Grade Adjusted Distance (<span class="math inline">\(x_g\)</span>) as well as all the observations in its time series. To make the data linear-regression-ready, I can engineer features of the form:</p>
<p><span class="math display">\[
  ftr_m = \sum\limits_{i=0}^{N_{obs}-1} g^m(i) \Delta x(i)
\]</span></p>
<p>…so that for each activity:</p>
<p><span class="math display">\[
  x_g = \sum\limits_{j=0}^5 c_j ftr_j
\]</span></p>
<p>…and when all activities are considered, a linear regression problem appears:</p>
<p><span class="math display">\[
  \mathbf{x_g} = \mathbf{F} \mathbf{c}
\]</span></p>
<p>…where <span class="math inline">\(\mathbf{F}\)</span> is the matrix of features that I extract from the activity time series: one row per activity, one column per feature.</p>
<p>There is an unwritten rule that basically says: you have to use <em>these specific variables</em> in data science:</p>
<p><span class="math display">\[\mathbf{y} = \mathbf{X} \mathbf{b}\]</span></p>
<p>So to summarize this confusing twist: - <span class="math inline">\(\mathbf{x_g} \rightarrow \mathbf{y}\)</span> (the targets) - <span class="math inline">\(\mathbf{F} \rightarrow \mathbf{X}\)</span> (the features) - <span class="math inline">\(\mathbf{c} \rightarrow \mathbf{b}\)</span> (the coefficients)</p>
<p>Please don’t blame me, I am just speaking the vernacular of data science, trying to fit in.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>poly_degree <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>X_raw <span class="op">=</span> pd.concat(</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  [(delta_x <span class="op">*</span> grade <span class="op">**</span> i).groupby(<span class="st">'id'</span>).<span class="bu">sum</span>() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(poly_degree <span class="op">+</span> <span class="dv">1</span>)],</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>y_raw <span class="op">=</span> grade_adjusted_distance.dropna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>shared_indices <span class="op">=</span> y_raw.index.intersection(X_raw.index)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> X_raw.loc[shared_indices, :]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> y_raw[shared_indices]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now to perform the linear regression itself, where I finally get to figure out the coefficients that give me the best fit.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> LinearRegression()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>model.fit(X, y)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> model.predict(X)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>rmse <span class="op">=</span> mean_squared_error(y, predictions, squared<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>rmse</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>35.85465857601326</code></pre>
</div>
</div>
<p>For context, the mean and median is on the order of 12000.</p>
<p>The fit’s <span class="math inline">\(R^2\)</span> value is close to 1.0. Let’s take a look at a scatterplot of my model’s predicted Grade Adjusted Distance values vs.&nbsp;“observations” from my Strava bulk download:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(y, predictions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>&lt;matplotlib.collections.PathCollection at 0x7efd724665e0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="grade-adjusted-pace_files/figure-html/cell-14-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>It looks like a straight line, right on the diagonal. Now, that isn’t a rigorous vetting of the model, but it is quite encouraging. To me, it validates the underlying assumptions - I’m not missing some major detail of Strava’s secret implementation.</p>
</section>
</section>
<section id="comparing-the-result-to-ground-truth" class="level2">
<h2 class="anchored" data-anchor-id="comparing-the-result-to-ground-truth">Comparing the result to ground truth</h2>
<p>In Strava’s blog post <a href="https://medium.com/strava-engineering/an-improved-gap-model-8b07ae8886c3">An Improved GAP Model</a>, there is a graph comparing their “improved” grade adjustment factor to their old one based on [[Minetti (2002)]]. I’ll create my own version of this graph, using the two adjustment factor models from my analysis.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>gradient_array <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">35</span>, <span class="dv">35</span>, <span class="dv">1000</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>poly <span class="op">=</span> np.polynomial.Polynomial(model.coef_)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>factor_model <span class="op">=</span> poly(gradient_array)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>factor_minetti <span class="op">=</span> cost_of_running(gradient_array<span class="op">/</span><span class="fl">100.0</span>) <span class="op">/</span> cost_of_running(<span class="fl">0.0</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>plt.plot(gradient_array, factor_model, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>plt.plot(gradient_array, factor_minetti, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="fl">1.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="fl">0.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">35</span>, <span class="dv">35</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">4</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="grade-adjusted-pace_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Look familiar??</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*_TwofsNS872wbUS12ykKPQ.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">adjustment factor comparison plot from Strava blog</figcaption><p></p>
</figure>
</div>
<p>Now to compare my model of Strava’s adjustment factor to <strong>exact</strong> values of the adjustment factor I obtained <em>elsewhere</em> (in a story for another time).</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> specialsauce.datasets <span class="im">import</span> load_ngp_gap</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>df_adjusted_pace <span class="op">=</span> load_ngp_gap()</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>factor_experiment <span class="op">=</span> df_adjusted_pace[<span class="st">'Pace'</span>] <span class="op">/</span> df_adjusted_pace[<span class="st">'GAP'</span>]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>gradient_array <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">50</span>, <span class="dv">50</span>, <span class="dv">100</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>factor_model <span class="op">=</span> poly(gradient_array)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="fl">1.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="fl">0.0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>plt.plot(gradient_array, poly(gradient_array))</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>plt.scatter(factor_experiment.index, factor_experiment, c<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="grade-adjusted-pace_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>I’ll take it. The model’s most severe deviation from reality occurs at a grade of 45% - the type of extreme slope that tends to be underrepresented in any runner’s fitness history. It makes sense that the model would underperform in a region of training data scarcity.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>With such a large number of data points (thanks to 2.5 million discrete samples in my time series history), it was tempting to throw computing power at the problem of reverse-engineering the GAP algorithm. I hope that this post highlights the potential for compute cost savings when a thoughtful modelling approach is adopted.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>